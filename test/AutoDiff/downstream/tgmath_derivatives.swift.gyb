// RUN: %target-run-simple-swiftgyb
// REQUIRES: executable_test

#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)
  import Darwin.C.tgmath
#elseif os(Linux) || os(FreeBSD) || os(PS4) || os(Android) || os(Cygwin) || os(Haiku)
  import Glibc
#elseif os(Windows)
  import MSVCRT
#else
#error("Unsupported platform")
#endif

#if (arch(i386) || arch(x86_64)) && !os(Windows)
  typealias TestLiteralType = Float80
#else
  typealias TestLiteralType = Double
#endif

import StdlibUnittest

let MathTests = TestSuite("TGMath")

func expectEqualWithTolerance<T>(_ expected: TestLiteralType, _ actual: T,
                                 ulps allowed: T = 3,
                                 file: String = #file, line: UInt = #line)
                                 where T: BinaryFloatingPoint {
  if actual == T(expected) || actual.isNaN && expected.isNaN {
    return
  }
  //  Compute error in ulp, compare to tolerance.
  let absoluteError = T(abs(TestLiteralType(actual) - expected))
  let ulpError = absoluteError / T(expected).ulp
  expectTrue(ulpError <= allowed,
             "\(actual) != \(expected) as \(T.self)" +
             "\n  \(ulpError)-ulp error exceeds \(allowed)-ulp tolerance.",
             file: file, line: line)
}

func checkGradient<T: BinaryFloatingPoint & Differentiable>(
  _ f: @differentiable (T, T) -> T,
  _ x: T,
  _ y: T)
where T == T.TangentVector {
  let eps = T(0.01)
  let grad = gradient(at: x, y, in: f)
  let dfdx = (f(x + eps, y) - f(x, y)) / eps
  let dfdy = (f(x, y + eps) - f(x, y)) / eps
  expectEqualWithTolerance(TestLiteralType(dfdx), grad.0, ulps: 192)
  expectEqualWithTolerance(TestLiteralType(dfdy), grad.1, ulps: 192)
}

% for T in ['Float', 'Float80']:
MathTests.test("gradient_${T}") {
  expectEqualWithTolerance(7.3890560989306502274, gradient(at: 2.0 as ${T}, in: exp), ulps: 16)
  expectEqualWithTolerance(2.772588722239781145, gradient(at: 2.0 as ${T}, in: exp2), ulps: 16)
  expectEqualWithTolerance(7.3890560989306502274, gradient(at: 2.0 as ${T}, in: expm1), ulps: 16)
  expectEqualWithTolerance(0.5, gradient(at: 2.0 as ${T}, in: log), ulps: 16)
  expectEqualWithTolerance(0.21714724095162590833, gradient(at: 2.0 as ${T}, in: log10), ulps: 16)
  expectEqualWithTolerance(0.7213475204444817278, gradient(at: 2.0 as ${T}, in: log2), ulps: 16)
  expectEqualWithTolerance(0.33333333333333333334, gradient(at: 2.0 as ${T}, in: log1p), ulps: 16)
  expectEqualWithTolerance(5.774399204041917612, gradient(at: 2.0 as ${T}, in: tan), ulps: 16)
  expectEqualWithTolerance(-0.9092974268256816954, gradient(at: 2.0 as ${T}, in: cos), ulps: 16)
  expectEqualWithTolerance(-0.416146836547142387, gradient(at: 2.0 as ${T}, in: sin), ulps: 16)
  expectEqualWithTolerance(1.154700538379251529, gradient(at: 0.5 as ${T}, in: asin), ulps: 16)
  expectEqualWithTolerance(-1.154700538379251529, gradient(at: 0.5 as ${T}, in: acos), ulps: 16)
  expectEqualWithTolerance(0.8, gradient(at: 0.5 as ${T}, in: atan), ulps: 16)
  expectEqualWithTolerance(3.7621956910836314597, gradient(at: 2.0 as ${T}, in: sinh), ulps: 16)
  expectEqualWithTolerance(3.6268604078470187677, gradient(at: 2.0 as ${T}, in: cosh), ulps: 16)
  expectEqualWithTolerance(0.07065082485316446565, gradient(at: 2.0 as ${T}, in: tanh), ulps: 16)
  expectEqualWithTolerance(0.44721359549995793928, gradient(at: 2.0 as ${T}, in: asinh), ulps: 16)
  expectEqualWithTolerance(0.5773502691896257645, gradient(at: 2.0 as ${T}, in: acosh), ulps: 16)
  expectEqualWithTolerance(1.3333333333333333334, gradient(at: 0.5 as ${T}, in: atanh), ulps: 16)
  expectEqualWithTolerance(0.020666985354092053575, gradient(at: 2.0 as ${T}, in: erf), ulps: 16)
  expectEqualWithTolerance(-0.020666985354092053575, gradient(at: 2.0 as ${T}, in: erfc), ulps: 16)
  expectEqualWithTolerance(0.35355339059327376222, gradient(at: 2.0 as ${T}, in: { sqrt($0) }), ulps: 16)
  let fmaGrad = gradient(at: 4.0 as ${T}, 5.0 as ${T}, 6.0 as ${T}, in: { x, y, z in fma(x, y, z) })
  expectEqualWithTolerance(5.0, fmaGrad.0, ulps: 16)
  expectEqualWithTolerance(4.0, fmaGrad.1, ulps: 16)
  expectEqualWithTolerance(1.0, fmaGrad.2, ulps: 16)
  expectEqualWithTolerance(0.0, gradient(at: 2.0 as ${T}, in: { ceil($0) }), ulps: 16)
  expectEqualWithTolerance(0.0, gradient(at: 2.0 as ${T}, in: { floor($0) }), ulps: 16)
  expectEqualWithTolerance(0.0, gradient(at: 2.0 as ${T}, in: { round($0) }), ulps: 16)
  expectEqualWithTolerance(0.0, gradient(at: 2.0 as ${T}, in: { trunc($0) }), ulps: 16)
  for a in -10...10 {
    let x = ${T}(a)
    for b in -10...10 {
      let y = ${T}(b)
      guard b != 0 && remainder(x, y).sign == remainder(x + ${T}(0.001), y).sign &&
        remainder(x, y).sign == remainder(x, y + ${T}(0.001)).sign
        else { continue }
      checkGradient({ remainder($0, $1) }, x, y)
      checkGradient({ fmod($0, $1) }, x, y)
    }
  }
}
%end

runAllTests()
